â­ï¸ Node JS
It is a javascript runtime environment.
NodeJS allows javascript to run outside of browser

â­ï¸ npm init
It is used to initialize new NodeJs project by creating a package.json file

â­ï¸ package.json
package.json is the metadata file for your project.
It includes info like:
    Project name, version, author
    Scripts (like npm start)
    Dependencies (packages you install)
    License, repository URL, etc.

â­ï¸ Module :
In JavaScript, a module is a file that encapsulates code and exports things (functions, variables, classes, etc.) that can be reused in other files.

# To export module :

ðŸŽˆ Way 1 : 
function add(a, b){
    return a + b
}

function sub(a, b){
    return a - b
}

module.exports = {      // Returns a single object
    add,
    sub
}

ðŸŽˆ Way 2 :
exports.add = (a, b) => a + b

exports.sub = (a, b) => a - b

# To import module :

const math = require("./02_modules")

â­ï¸ File Handling :

let fs = require('fs')            // Importing built-in module to enable file handling

# To create/write File

Syncronous Call
fs.writeFileSync("./text.txt", "Hello World 123")

Asyncronous Call
fs.writeFile("./text.txt", "Async Hello World", (err) => {          // Callback Fn runs when execution is completed
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
    console.log('File written successfully.');
})

# To read a file

// Synchronous Call
let fileData = fs.readFileSync("text.txt", "utf-8")
console.log(fileData)

// Async Call
fs.readFile("text.txt", "utf-8", (err, data)=>{     // â€¼ï¸ Note that readFile() returns undefined
    if(err){
        console.log("Error : " + err)
    }else{
        console.log(data)
    }
})

# Append content in File

// Sync Call
fs.appendFileSync("./text.txt", "\n This is a new line.")

// Async Call
fs.appendFile("./text.txt", "\n This is a new async line.", (err) => {         
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
})

# Copy a file to another file

// Sync Call
fs.copyFileSync("text.txt", "destination.txt")

// Async Call
fs.copyFile("./00_temp.js", "./destination.txt", (err) => {
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
})

# Delete a file 

// Sync Call
fs.unlinkSync("destination.txt")

// Async Call
fs.unlink("destination.txt", (err) => {
    if (err) {
        console.error('Error deleting file:', err.message);
        return;
    }
})

# Get file stats

// Sync Call
let info = fs.statSync("./package.json");

console.log(info);                           // Returns obj   
console.log(info.isFile());                  // Returns boolean
console.log(info.isDirectory());             // Returns boolean
console.log(info.size);                      // Returns bytes
console.log('Created on:', info.birthtime);

// Async Call
fs.stat("./package.json", (err, stats) => {
    if (err) {
        console.error(err.message);
        return;
    }

    console.log(stats)
})

# Create a directory

// Sync Call
fs.mkdirSync("new_dir")                     // â€¼ï¸ Throws error if directory already exists

// Async Call
fs.mkdir("new_dir", (err)=>{
    if (err) {
        console.error(err.message);
        return;
    }
})

# Delete a directory

// Sync Call
fs.rmSync('new_dir', { recursive: true })

â­ï¸ NodeJS Working

# Async Call

User Request
    |
    V
Event Queue (Stores Request)
    |
    V
Event Loop (Checks for the request)
    |
    V
Non-Blocking operation
    |
    V
Returns response

# Sync Call

User Request
    |
    V
Event Queue (Stores Request)
    |
    V
Event Loop (Checks for the request)
    |
    V
Blocking operation
    |
    V
Assign Task to thread/worker from treadpool
    |
    V
Returns response

â­ï¸ Building WebServer

// S1. Importing built-in 'http' module
let http = require("http");

// S2. Creating WebServer
let myServer = http.createServer((req, res)=>{          // The callback Fn is the request Handler.
    //code
})

// S3. To Set port number :
http.listen(3000, ()=>{
    console.log("Server Started")
})

// ðŸŽˆ Example 1 : 

let http = require("http");
let fs = require("fs")

let myServer = http.createServer((req, res) => {
    fs.appendFile("log.txt", `${Date.now()} : ${req.url}\n`, (err)=>{
        if(err){
            console.log(err.message)
        }
    })
    res.end("Thankyou for visiting.")
})

myServer.listen(3000, ()=>{
    console.log("Server started")
})

â­ï¸ Handling URL

// Install Package
npm i url

// Import Package
let url = require("url")

// Parsing URL
let myURL = url.parse(req.url)

console.log(myURL.pathname)         // To get pathName

â­ï¸ ExpressJs

// Install Package
npm i express

// Import Package
let express = require("express")

let app = express()                 // Create an instance of an Express application

// In plain nodeJS :
const http = require('http');
const server = http.createServer(...);

// In expressJS :
const express = require('express');
const app = express();  // Like your "server"

app.get("/", (req, res)=>{
    // console.log(req.query)                               // Query Paramter Object { name: 'sahil', id: '202' }
    // console.log(req.headers)                             // Returns Obj containing headers
    // console.log(req.method);                             // Returns http method
    // console.log(req.url);                                // /?name=sahil&id=202
    // console.log("req.path : " + req.path)                // /about
    // console.log("req.hostname : " + req.hostname)        // localhost
    // console.log("req.protocol : " + req.protocol)        // http
    // console.log("req.cookies : " + req.cookies)          // Cookies (if cookie-parser middleware is used)
    // console.log("req.ip : " + req.ip)                    // IP address of the client
    
    return res.send(`This is a home page.`)
})

app.get("/about", (req, res)=>{
    return res.send(`This is a about page. Your Name is ${req.query.name} and age is ${req.query.age}`)
})

app.get("/contact", (req, res)=>{
    return res.send(`This is a contact page. Your Name is ${req.query.name} and age is ${req.query.age}`)
})

app.listen(3000, ()=>{
    console.log("Server started")
})

â­ï¸ Versioning in nodeJS

Suppose version = ^4.18.2

^                       -> Locks the major version (e.g. ^4.18.2, the version can update from 4.18.2 < 5.0.0)
~                       -> Accepts only patch update
1st Part : 4    (Major) -> Redesigns (If code depends on Express4 behavior, upgrading to Express5 might crash or break your app unless you refactor it.)
2nd Part : 18   (Minor) -> New Features (No breaking changes â€” your current code continues to work)
3rd Part : 2    (Patch) -> Bug Fixes (Optional)

â­ï¸ Building REST API using nodeJS and expressJS

// S1. Import ExpressJS package
let express = require("express");

// S2. Create app of the package
let app = express();

// S3. Create app of the package
let app = express();

// ðŸŽˆ Get Request

app.get("/api/users", (req, res)=>{
    res.send(mock_data)                         // Returns response
})

// ðŸŽˆ Get Request using dynamic routing (Get ID from the URL)

app.get("/api/users/:id", (req, res) => {
    console.log(req.params.id)                  // req.params.id returns string
    res.send("Hello World")
})

// ðŸŽˆ POST Request

app.post("/api/users", (req, res)=>{
    return res.json( { status : "pending" } )
})

// ðŸŽˆ PATCH Request

app.patch("/api/users/:id", (req, res)=>{
    let id = req.params.id
    return res.json( { status : "pending" } )
})

// ðŸŽˆ DELETE Request

app.delete("/api/users/:id", (req, res)=>{
    let id = req.params.id
    return res.json( { status : "pending" } )
})

// ðŸŽˆ Chaining routes for common URL

// âœ… app.route() returns a Route object â€” not a middleware, not a router.
// This Route object allows you to chain HTTP method handlers (like .get(), .post(), etc.) for a single path.

app
    .route("/api/users")
    .get((req, res) => {
        if (req.path == "/fav.ico") { return; }
        res.send(mock_data)
    })
    .post((req, res) => {
        return res.json({ status: "pending" })
    })

app
    .route("/api/users/:id")
    .get((req, res) => {
        let id = req.params.id
        let user = mock_data.find(x => x.id == id)
        res.send(user)
    })
    .patch((req, res) => {
        let id = req.params.id
        return res.json({ status: "pending" })
    })
    .delete((req, res) => {
        let id = req.params.id
        return res.json({ status: "pending" })
    })




