â­ï¸ Node JS
It is a javascript runtime environment.
NodeJS allows javascript to run outside of browser

â­ï¸ npm init
It is used to initialize new NodeJs project by creating a package.json file

â­ï¸ package.json
package.json is the metadata file for your project.
It includes info like:
    Project name, version, author
    Scripts (like npm start)
    Dependencies (packages you install)
    License, repository URL, etc.

â­ï¸ Module :
In JavaScript, a module is a file that encapsulates code and exports things (functions, variables, classes, etc.) that can be reused in other files.

# To export module :

ðŸŽˆ Way 1 : 
function add(a, b){
    return a + b
}

function sub(a, b){
    return a - b
}

module.exports = {      // Returns a single object
    add,
    sub
}

ðŸŽˆ Way 2 :
exports.add = (a, b) => a + b

exports.sub = (a, b) => a - b

# To import module :

const math = require("./02_modules")

â­ï¸ File Handling :

// Importing built-in module to enable file handling
let fs = require('fs')            

# To create/write File

Syncronous Call
fs.writeFileSync("./text.txt", "Hello World 123")

Asyncronous Call
fs.writeFile("./text.txt", "Async Hello World", (err) => {          // Callback Fn runs when execution is completed
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
    console.log('File written successfully.');
})

# To read a file

// Synchronous Call
let fileData = fs.readFileSync("text.txt", "utf-8")
console.log(fileData)

// Async Call
fs.readFile("text.txt", "utf-8", (err, data)=>{     // â€¼ï¸ Note that readFile() returns undefined
    if(err){
        console.log("Error : " + err)
    }else{
        console.log(data)
    }
})

# Append content in File

// Sync Call
fs.appendFileSync("./text.txt", "\n This is a new line.")

// Async Call
fs.appendFile("./text.txt", "\n This is a new async line.", (err) => {         
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
})

# Copy a file to another file

// Sync Call
fs.copyFileSync("text.txt", "destination.txt")

// Async Call
fs.copyFile("./00_temp.js", "./destination.txt", (err) => {
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
})

# Delete a file 

// Sync Call
fs.unlinkSync("destination.txt")

// Async Call
fs.unlink("destination.txt", (err) => {
    if (err) {
        console.error('Error deleting file:', err.message);
        return;
    }
})

# Get file stats

// Sync Call
let info = fs.statSync("./package.json");

console.log(info);                           // Returns obj   
console.log(info.isFile());                  // Returns boolean
console.log(info.isDirectory());             // Returns boolean
console.log(info.size);                      // Returns bytes
console.log('Created on:', info.birthtime);

// Async Call
fs.stat("./package.json", (err, stats) => {
    if (err) {
        console.error(err.message);
        return;
    }

    console.log(stats)
})

# Create a directory

// Sync Call
fs.mkdirSync("new_dir")                     // â€¼ï¸ Throws error if directory already exists

// Async Call
fs.mkdir("new_dir", (err)=>{
    if (err) {
        console.error(err.message);
        return;
    }
})

# Delete a directory

// Sync Call
fs.rmSync('new_dir', { recursive: true })

â­ï¸ NodeJS Working

# Async Call

User Request
    |
    V
Event Queue (Stores Request)
    |
    V
Event Loop (Checks for the request)
    |
    V
Non-Blocking operation
    |
    V
Returns response

# Sync Call

User Request
    |
    V
Event Queue (Stores Request)
    |
    V
Event Loop (Checks for the request)
    |
    V
Blocking operation
    |
    V
Assign Task to thread/worker from treadpool
    |
    V
Returns response

â­ï¸ Building WebServer

// S1. Importing built-in 'http' module
let http = require("http");

// S2. Creating WebServer
let myServer = http.createServer((req, res)=>{          // The callback Fn is the request Handler.
    //code
})

// S3. To Set port number :
myServer.listen(3000, ()=>{
    console.log("Server Started")
})

// ðŸŽˆ Example 1 : 

let http = require("http");
let fs = require("fs")

let myServer = http.createServer((req, res) => {
    fs.appendFile("log.txt", `${Date.now()} : ${req.url}\n`, (err)=>{
        if(err){
            console.log(err.message)
        }
    })
    res.end("Thankyou for visiting.")
})

myServer.listen(3000, ()=>{
    console.log("Server started")
})

â­ï¸ Handling URL

// Install Package
npm i url

// Import Package
let url = require("url")

// Parsing URL
let myURL = url.parse(req.url)

console.log(myURL.pathname)         // To get pathName

â­ï¸ ExpressJs

// Install Package
npm i express

// Import Package
let express = require("express")

let app = express()                 // Create an instance of an Express application

// In plain nodeJS :
const http = require('http');
const server = http.createServer(...);

// In expressJS :
const express = require('express');
const app = express();  // Like your "server"

app.get("/", (req, res)=>{
    // console.log(req.query)                               // Query Paramter Object { name: 'sahil', id: '202' }
    // console.log(req.headers)                             // Returns Obj containing headers
    // console.log(req.method);                             // Returns http method
    // console.log(req.url);                                // /?name=sahil&id=202
    // console.log("req.path : " + req.path)                // /about
    // console.log("req.hostname : " + req.hostname)        // localhost
    // console.log("req.protocol : " + req.protocol)        // http
    // console.log("req.cookies : " + req.cookies)          // Cookies (if cookie-parser middleware is used)
    // console.log("req.ip : " + req.ip)                    // IP address of the client
    
    return res.send(`This is a home page.`)
})

app.get("/about", (req, res)=>{
    return res.send(`This is a about page. Your Name is ${req.query.name} and age is ${req.query.age}`)
})

app.get("/contact", (req, res)=>{
    return res.send(`This is a contact page. Your Name is ${req.query.name} and age is ${req.query.age}`)
})

app.listen(3000, ()=>{
    console.log("Server started")
})

â­ï¸ Versioning in nodeJS

Suppose version = ^4.18.2

^                       -> Locks the major version (e.g. ^4.18.2, the version can update from 4.18.2 < 5.0.0)
~                       -> Accepts only patch update
1st Part : 4    (Major) -> Redesigns (If code depends on Express4 behavior, upgrading to Express5 might crash or break your app unless you refactor it.)
2nd Part : 18   (Minor) -> New Features (No breaking changes â€” your current code continues to work)
3rd Part : 2    (Patch) -> Bug Fixes (Optional)

â­ï¸ Building REST API using nodeJS and expressJS

// S1. Import ExpressJS package
let express = require("express");

// S2. Create app of the package
let app = express();

// ðŸŽˆ To parse the data coming from postman body (JSON)

app.use(express.json());                // Add this middleware

# Reads the raw JSON from the request body
# Parses it into a JS object
# Stores it on req.body

// ðŸŽˆ Get Request

app.get("/api/users", (req, res)=>{
    res.send(mock_data)                         // Returns response
})

// ðŸŽˆ Get Request using dynamic routing (Get ID from the URL)

app.get("/api/users/:id", (req, res) => {
    console.log(req.params.id)                  // req.params.id returns string
    res.send("Hello World")
})

// ðŸŽˆ POST Request

app.post("/api/users", (req, res)=>{
    return res.json( { status : "pending" } )
})

// ðŸŽˆ PATCH Request

app.patch("/api/users/:id", (req, res)=>{
    let id = req.params.id
    return res.json( { status : "pending" } )
})

// ðŸŽˆ DELETE Request

app.delete("/api/users/:id", (req, res)=>{
    let id = req.params.id
    return res.json( { status : "pending" } )
})

// ðŸŽˆ Chaining routes for common URL

// âœ… app.route() returns a Route object â€” not a middleware, not a router.
// This Route object allows you to chain HTTP method handlers (like .get(), .post(), etc.) for a single path.

app
    .route("/api/users")
    .get((req, res) => {
        if (req.path == "/fav.ico") { return; }
        res.send(mock_data)
    })
    .post((req, res) => {
        return res.json({ status: "pending" })
    })

app
    .route("/api/users/:id")
    .get((req, res) => {
        let id = req.params.id
        let user = mock_data.find(x => x.id == id)
        res.send(user)
    })
    .patch((req, res) => {
        let id = req.params.id
        return res.json({ status: "pending" })
    })
    .delete((req, res) => {
        let id = req.params.id
        return res.json({ status: "pending" })
    })

â­ï¸ middleware

A middleware is a function that executes during the request-response cycle and can:
Modify the request or response
End the request-response cycle
Pass control to the next middleware in the stack

// ðŸŽˆ FLOW :

client -> middleware1 -> middleware2 -> middleware3 -> server

// ðŸŽˆ To create custom middleware

app.use((req, res, next)=>{
    console.log("Hello from middleware 1");
    next()                                      // Calls next middleware
})

// ðŸŽˆ middleware Chaining

// To create custom middleware
app.use((req, res, next)=>{
    console.log("Hello from middleware 1");
    next()
})

app.use((req, res, next) => {
    console.log("This is middleware 2")
    next()
})

// ðŸŽˆ Modifying Req/Res object

app.use((req, res, next) => {
    console.log("Hello from middleware 1");
    req.username = "Ankit Manjrekar"                    // Adding Property
    next()
})

app.use((req, res, next) => {
    console.log("This is middleware 2")
    console.log(req.username)
    return res.send({ status: "success" })
})

// ðŸŽˆ Terminating req/res cycle using middleware

app.use((req, res, next) => {
    console.log("Hello from middleware 1");
    next()
})

app.use((req, res, next) => {
    console.log("This is middleware 2")
    return res.send({ status: "success" })          // This will end the request without reaching the server
})

â­ï¸ Router
// A router is a separate file or module where you define related routes (e.g., /users, /products).
// express.Router() is a mini Express app used to create modular route handlers.
// Like seperate routing files for student, teachers

#### In studentRoutes.js

// To create router :
const express = require('express');
const router = express.Router();

// Same, just replace app with router
router
    .route("/")
    .get((req, res) => {
        // Gets All Students
        return res.json(students);
    })

// Export the module
module.exports = router;

#### In main file,

let studentRoutes = require("./routes/studentRoutes")
let express = require("express")
let app = express()

app.use(express.json());

app.use("/api/students", studentRoutes)                     // Connect to router

app.listen(3000, () => {
    console.log("Server Started");
})


â­ï¸ headers

// To set custom response header

app.get("/", (req, res) => {
    res.setHeader("X-MyName", "Ankit Manjrekar");         // This will add header to response
    res.send("Success")
})

// ðŸŽˆ Best Practice : Always add X for custom headers

// To read request header

app.get("/", (req, res) => {
    console.log(req.headers)
    res.send("Success")
})

â­ï¸ Http Status Code :

Informational responses (100 - 199)
Successful responses    (200 - 299)
Redirectional messages  (300 - 399)
Client error responses  (400 - 499)
Server error responses  (500 - 599)

# Common status code : 
200 : Ok. The request succeeded, GET request
201 : Created. The request succeeded, and a new resource was created as a result. POST & PUT Request
400 : Bad Request. Some data is missing in the request body
401 : Unauthorized
403 : Forbidden. The client does not have access rights to the content
404 : Not Found. The server cannot find the requested resource.
500 : Internal Server Error. The server has encountered a situation it does not know how to handle.

// To set status code on response :
res.status(201).json({ status: "success", id: student.id })

â­ï¸ Websocket

// Websocket is a protocol(like http) where we can achieve bi-directional communication.
// In normal http request, the client sends the request, server reponds to it and connection is closed.
// The server cannot send responses by itself or after connection is closed.
// Unlike HTTP, WebSocket allows real-time two-way communication between client and server.
// Commonly used in chat apps, real-time dashboards, games, etc.

# Socket.IO
// To achieve websocket in nodeJS, we have socket.io library

# In websocket.js,

// To import socket.io
let { Server } = require("socket.io"); 

// Create instance of socket.io and connect with http Server
let app = express();
let httpServer = http.createServer(app); 
let io = new Server(httpServer);                        // HTTP server can handle both HTTP (Express) and WebSocket (Socket.IO) traffic.

// To act on event 
io.on("connection", (socket) => {
    console.log("A user connected : " + socket.id);

    socket.on('disconnect', () => {
        console.log('user disconnected');
    });

    // When user sends message
    socket.on("user-msg", (msg) => {
        // socket.broadcast.emit("chat-msg", msg);      // it sends a message to all other connected clients, except that one socket that just sent msg.
        io.emit("chat-msg", {id : socket.id, msg})      // Sends message to everyone
    })
})

httpServer.listen(3000, () => {
    console.log("Server Started");
})


// In HTML,
<script src="/socket.io/socket.io.js"></script>
    <script>
        let socket = io();
        let input = document.querySelector("#message")
        let submitBtn = document.querySelector("#submitBtn")

        submitBtn.addEventListener("click", (e)=>{
            let msg = input.value;

            socket.emit("user-msg", msg);               // To send message to server
            input.value = "";
        })

        socket.on("chat-msg", (msg)=>{                  // To act on server message
            console.log(msg);
        })
    </script>












