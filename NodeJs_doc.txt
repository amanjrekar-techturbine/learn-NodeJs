‚≠êÔ∏è Node JS
It is a javascript runtime environment.
NodeJS allows javascript to run outside of browser

‚≠êÔ∏è npm init
It is used to initialize new NodeJs project by creating a package.json file

‚≠êÔ∏è package.json
package.json is the metadata file for your project.
It includes info like:
    Project name, version, author
    Scripts (like npm start)
    Dependencies (packages you install)
    License, repository URL, etc.

‚≠êÔ∏è Module :
In JavaScript, a module is a file that encapsulates code and exports things (functions, variables, classes, etc.) that can be reused in other files.

# To export module :

üéà Way 1 : 
function add(a, b){
    return a + b
}

function sub(a, b){
    return a - b
}

module.exports = {      // Returns a single object
    add,
    sub
}

üéà Way 2 :
exports.add = (a, b) => a + b

exports.sub = (a, b) => a - b

# To import module :

const math = require("./02_modules")

‚≠êÔ∏è File Handling :

// Importing built-in module to enable file handling
let fs = require('fs')            

# To create/write File

Syncronous Call
fs.writeFileSync("./text.txt", "Hello World 123")

Asyncronous Call
fs.writeFile("./text.txt", "Async Hello World", (err) => {          // Callback Fn runs when execution is completed
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
    console.log('File written successfully.');
})

# To read a file

// Synchronous Call
let fileData = fs.readFileSync("text.txt", "utf-8")
console.log(fileData)

// Async Call
fs.readFile("text.txt", "utf-8", (err, data)=>{     // ‚ÄºÔ∏è Note that readFile() returns undefined
    if(err){
        console.log("Error : " + err)
    }else{
        console.log(data)
    }
})

# Append content in File

// Sync Call
fs.appendFileSync("./text.txt", "\n This is a new line.")

// Async Call
fs.appendFile("./text.txt", "\n This is a new async line.", (err) => {         
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
})

# Copy a file to another file

// Sync Call
fs.copyFileSync("text.txt", "destination.txt")

// Async Call
fs.copyFile("./00_temp.js", "./destination.txt", (err) => {
    if (err) {
        console.error('Error writing file:', err);
        return;
    }
})

# Delete a file 

// Sync Call
fs.unlinkSync("destination.txt")

// Async Call
fs.unlink("destination.txt", (err) => {
    if (err) {
        console.error('Error deleting file:', err.message);
        return;
    }
})

# Get file stats

// Sync Call
let info = fs.statSync("./package.json");

console.log(info);                           // Returns obj   
console.log(info.isFile());                  // Returns boolean
console.log(info.isDirectory());             // Returns boolean
console.log(info.size);                      // Returns bytes
console.log('Created on:', info.birthtime);

// Async Call
fs.stat("./package.json", (err, stats) => {
    if (err) {
        console.error(err.message);
        return;
    }

    console.log(stats)
})

# Create a directory

// Sync Call
fs.mkdirSync("new_dir")                     // ‚ÄºÔ∏è Throws error if directory already exists

// Async Call
fs.mkdir("new_dir", (err)=>{
    if (err) {
        console.error(err.message);
        return;
    }
})

# Delete a directory

// Sync Call
fs.rmSync('new_dir', { recursive: true })

‚≠êÔ∏è NodeJS Working

# Async Call

User Request
    |
    V
Event Queue (Stores Request)
    |
    V
Event Loop (Checks for the request)
    |
    V
Non-Blocking operation
    |
    V
Returns response

# Sync Call

User Request
    |
    V
Event Queue (Stores Request)
    |
    V
Event Loop (Checks for the request)
    |
    V
Blocking operation
    |
    V
Assign Task to thread/worker from treadpool
    |
    V
Returns response

‚≠êÔ∏è Building WebServer

// S1. Importing built-in 'http' module
let http = require("http");

// S2. Creating WebServer
let myServer = http.createServer((req, res)=>{          // The callback Fn is the request Handler.
    //code
})

// S3. To Set port number :
myServer.listen(3000, ()=>{
    console.log("Server Started")
})

// üéà Example 1 : 

let http = require("http");
let fs = require("fs")

let myServer = http.createServer((req, res) => {
    fs.appendFile("log.txt", `${Date.now()} : ${req.url}\n`, (err)=>{
        if(err){
            console.log(err.message)
        }
    })
    res.end("Thankyou for visiting.")
})

myServer.listen(3000, ()=>{
    console.log("Server started")
})

‚≠êÔ∏è Handling URL

// Install Package
npm i url

// Import Package
let url = require("url")

// Parsing URL
let myURL = url.parse(req.url)

console.log(myURL.pathname)         // To get pathName

‚≠êÔ∏è ExpressJs

// Install Package
npm i express

// Import Package
let express = require("express")

let app = express()                 // Create an instance of an Express application

// In plain nodeJS :
const http = require('http');
const server = http.createServer(...);

// In expressJS :
const express = require('express');
const app = express();  // Like your "server"

app.get("/", (req, res)=>{
    // console.log(req.query)                               // Query Paramter Object { name: 'sahil', id: '202' }
    // console.log(req.headers)                             // Returns Obj containing headers
    // console.log(req.method);                             // Returns http method
    // console.log(req.url);                                // /?name=sahil&id=202
    // console.log("req.path : " + req.path)                // /about
    // console.log("req.hostname : " + req.hostname)        // localhost
    // console.log("req.protocol : " + req.protocol)        // http
    // console.log("req.cookies : " + req.cookies)          // Cookies (if cookie-parser middleware is used)
    // console.log("req.ip : " + req.ip)                    // IP address of the client
    
    return res.send(`This is a home page.`)
})

app.get("/about", (req, res)=>{
    return res.send(`This is a about page. Your Name is ${req.query.name} and age is ${req.query.age}`)
})

app.get("/contact", (req, res)=>{
    return res.send(`This is a contact page. Your Name is ${req.query.name} and age is ${req.query.age}`)
})

app.listen(3000, ()=>{
    console.log("Server started")
})

‚≠êÔ∏è Versioning in nodeJS

Suppose version = ^4.18.2

^                       -> Locks the major version (e.g. ^4.18.2, the version can update from 4.18.2 < 5.0.0)
~                       -> Accepts only patch update
1st Part : 4    (Major) -> Redesigns (If code depends on Express4 behavior, upgrading to Express5 might crash or break your app unless you refactor it.)
2nd Part : 18   (Minor) -> New Features (No breaking changes ‚Äî your current code continues to work)
3rd Part : 2    (Patch) -> Bug Fixes (Optional)

‚≠êÔ∏è Building REST API using nodeJS and expressJS

// S1. Import ExpressJS package
let express = require("express");

// S2. Create app of the package
let app = express();

// üéà To parse the data coming from postman body (JSON)

app.use(express.json());                // Add this middleware

# Reads the raw JSON from the request body
# Parses it into a JS object
# Stores it on req.body

// üéà Get Request

app.get("/api/users", (req, res)=>{
    res.send(mock_data)                         // Returns response
})

// üéà Get Request using dynamic routing (Get ID from the URL)

app.get("/api/users/:id", (req, res) => {
    console.log(req.params.id)                  // req.params.id returns string
    res.send("Hello World")
})

// üéà POST Request

app.post("/api/users", (req, res)=>{
    return res.json( { status : "pending" } )
})

// üéà PATCH Request

app.patch("/api/users/:id", (req, res)=>{
    let id = req.params.id
    return res.json( { status : "pending" } )
})

// üéà DELETE Request

app.delete("/api/users/:id", (req, res)=>{
    let id = req.params.id
    return res.json( { status : "pending" } )
})

// üéà Chaining routes for common URL

// ‚úÖ app.route() returns a Route object ‚Äî not a middleware, not a router.
// This Route object allows you to chain HTTP method handlers (like .get(), .post(), etc.) for a single path.

app
    .route("/api/users")
    .get((req, res) => {
        if (req.path == "/fav.ico") { return; }
        res.send(mock_data)
    })
    .post((req, res) => {
        return res.json({ status: "pending" })
    })

app
    .route("/api/users/:id")
    .get((req, res) => {
        let id = req.params.id
        let user = mock_data.find(x => x.id == id)
        res.send(user)
    })
    .patch((req, res) => {
        let id = req.params.id
        return res.json({ status: "pending" })
    })
    .delete((req, res) => {
        let id = req.params.id
        return res.json({ status: "pending" })
    })

‚≠êÔ∏è middleware

A middleware is a function that executes during the request-response cycle and can:
Modify the request or response
End the request-response cycle
Pass control to the next middleware in the stack

// üéà FLOW :

client -> middleware1 -> middleware2 -> middleware3 -> server

// üéà To create custom middleware

app.use((req, res, next)=>{
    console.log("Hello from middleware 1");
    next()                                      // Calls next middleware
})

// üéà middleware Chaining

// To create custom middleware
app.use((req, res, next)=>{
    console.log("Hello from middleware 1");
    next()
})

app.use((req, res, next) => {
    console.log("This is middleware 2")
    next()
})

// üéà Modifying Req/Res object

app.use((req, res, next) => {
    console.log("Hello from middleware 1");
    req.username = "Ankit Manjrekar"                    // Adding Property
    next()
})

app.use((req, res, next) => {
    console.log("This is middleware 2")
    console.log(req.username)
    return res.send({ status: "success" })
})

// üéà Terminating req/res cycle using middleware

app.use((req, res, next) => {
    console.log("Hello from middleware 1");
    next()
})

app.use((req, res, next) => {
    console.log("This is middleware 2")
    return res.send({ status: "success" })          // This will end the request without reaching the server
})

‚≠êÔ∏è Router
// A router is a separate file or module where you define related routes (e.g., /users, /products).
// express.Router() is a mini Express app used to create modular route handlers.
// Like seperate routing files for student, teachers

#### In studentRoutes.js

// To create router :
const express = require('express');
const router = express.Router();

// Same, just replace app with router
router
    .route("/")
    .get((req, res) => {
        // Gets All Students
        return res.json(students);
    })

// Export the module
module.exports = router;

#### In main file,

let studentRoutes = require("./routes/studentRoutes")
let express = require("express")
let app = express()

app.use(express.json());

app.use("/api/students", studentRoutes)                     // Connect to router

app.listen(3000, () => {
    console.log("Server Started");
})


‚≠êÔ∏è headers

// To set custom response header

app.get("/", (req, res) => {
    res.setHeader("X-MyName", "Ankit Manjrekar");         // This will add header to response
    res.send("Success")
})

// üéà Best Practice : Always add X for custom headers

// To read request header

app.get("/", (req, res) => {
    console.log(req.headers)
    res.send("Success")
})

‚≠êÔ∏è Http Status Code :

Informational responses (100 - 199)
Successful responses    (200 - 299)
Redirectional messages  (300 - 399)
Client error responses  (400 - 499)
Server error responses  (500 - 599)

# Common status code : 
200 : Ok. The request succeeded, GET request
201 : Created. The request succeeded, and a new resource was created as a result. POST & PUT Request
400 : Bad Request. Some data is missing in the request body
401 : Unauthorized
403 : Forbidden. The client does not have access rights to the content
404 : Not Found. The server cannot find the requested resource.
500 : Internal Server Error. The server has encountered a situation it does not know how to handle.

// To set status code on response :
res.status(201).json({ status: "success", id: student.id })

‚≠êÔ∏è Websocket

// Websocket is a protocol(like http) where we can achieve bi-directional communication.
// In normal http request, the client sends the request, server reponds to it and connection is closed.
// The server cannot send responses by itself or after connection is closed.
// Unlike HTTP, WebSocket allows real-time two-way communication between client and server.
// Commonly used in chat apps, real-time dashboards, games, etc.

# Socket.IO
// To achieve websocket in nodeJS, we have socket.io library

# In websocket.js,

// To import socket.io
let { Server } = require("socket.io"); 

// Create instance of socket.io and connect with http Server
let app = express();
let httpServer = http.createServer(app); 
let io = new Server(httpServer);                        // HTTP server can handle both HTTP (Express) and WebSocket (Socket.IO) traffic.

// To act on event 
io.on("connection", (socket) => {
    console.log("A user connected : " + socket.id);

    socket.on('disconnect', () => {
        console.log('user disconnected');
    });

    // When user sends message
    socket.on("user-msg", (msg) => {
        // socket.broadcast.emit("chat-msg", msg);      // it sends a message to all other connected clients, except that one socket that just sent msg.
        io.emit("chat-msg", {id : socket.id, msg})      // Sends message to everyone
    })
})

httpServer.listen(3000, () => {
    console.log("Server Started");
})


// In HTML,
<script src="/socket.io/socket.io.js"></script>
    <script>
        let socket = io();
        let input = document.querySelector("#message")
        let submitBtn = document.querySelector("#submitBtn")

        submitBtn.addEventListener("click", (e)=>{
            let msg = input.value;

            socket.emit("user-msg", msg);               // To send message to server
            input.value = "";
        })

        socket.on("chat-msg", (msg)=>{                  // To act on server message
            console.log(msg);
        })
    </script>

‚≠êÔ∏è Rooms In Websocket

// To create room and join : (In serverside)
socket.join(roomName);

// To send Msg in room : (In serverside)
io.to(roomName).emit("serverMsg", msg, username);

// To leave room :
socket.leave('room1');

‚≠êÔ∏è Server side rendering

EJS (Embedded JavaScript Templates) is a templating engine for Node.js, 
commonly used with ExpressJS to render HTML pages dynamically using JavaScript.

# Tags :

1. <%= variable %> ‚Üí Escaped Output

<p>Your name is: <%= name %></p>

2. <%- variable %> ‚Üí Unescaped Output

<%- "<b>bold</b>" %>

3. <% code %> ‚Üí Scriptlet Tag (no output)

<% if (user) { %>
  <p>Hello, <%= user.name %></p>
<% } %>

# In backend,

res.render("profile", { name: "Ankit Manjrekar" })

‚≠êÔ∏è MVC architecture

M = Model ‚Äì Database logic
V = View ‚Äì Presentation layer
C = Controller - business logic

WorkFlow : 

Client ‚Üí Routes ‚Üí Controller ‚Üí Model ‚Üí DB
   ‚Üë                             ‚Üì
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ View ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚≠êÔ∏è PostgreSQL

// Install Package
npm i pg

// Import Package
let { Client } = require("pg");

// Creating connection :

const con = new Client({
    host: "localhost",
    user: "postgres",
    port: 5433,
    password: "Tech1mini",
    database: "demodb"
})

con.connect().then(()=>{
    console.log("Connected")
})

# POST DATA
app.post("/api/students", (req, res)=>{
    let {id, name, age, grade} = req.body

    let query = `INSERT INTO students(id, name, age, grade) VALUES($1, $2, $3, $4) `

    con.query(query, [id, name, age, grade], (err, result)=>{
        if(err){
            res.send(err.message);
        }else{
            console.log(result)
            res.send("Student added successfully");
        }
    })
})

# GET All
app.get("/api/students", async (req, res) => {
    let query = "SELECT * FROM students";

    try {
        let result = await con.query(query);
        return res.json(result.rows);
    } catch (err) {
        return res.send(err.message)
    }
})

# GET BY ID
app.get("/api/students/:id", async (req, res) => {

    let id = req.params.id;

    let query = "SELECT * FROM students WHERE id=$1";

    try {

        let result = await con.query(query, [id]);

        if (result.rowCount == 0) {
            return res.status(404).send("Student Not Found");
        }

        return res.json(result.rows);

    } catch (err) {
        return res.send(err.message);
    }
})

# PUT REQUEST
app.put("/api/students/:id", async (req, res) => {
    let id = req.params.id;
    let { name, age, grade } = req.body;

    if(!name || !age || !grade){
        return res.status(400).send("Please Send All Fields");
    }

    let query = "UPDATE students SET name=$1, age=$2, grade=$3 WHERE id=$4";

    try {

        let result = await con.query(query, [name, age, grade, id]);

        if (result.rowCount == 0) {
            return res.status(404).send("Student Not Found");
        }

        return res.send("Student Updated Successfully");

    } catch (err) {
        return res.send(err.message);
    }
})

# DELETE REQUEST
app.delete("/api/students/:id", async (req, res) => {
    let id = req.params.id;

    let query = "DELETE FROM students WHERE id=$1";

    try {

        let result = await con.query(query, [id]);

        if(result.rowCount == 0){
            return res.status(404).send("Student Not Found");
        }

        return res.send("Student Deleted Successfully");

    } catch (err) {
        return res.send(err.message);
    }


});

# PATCH REQUEST
app.patch("/api/students/:id", async (req, res)=>{

    let id = req.params.id;
    let {name, age, grade} = req.body;

    let fields = [];
    let values = [];
    let index = 1;

    if(name){
        fields.push(`name=$${index++}`);
        values.push(name);
    }

    if(age){
        fields.push(`age=$${index++}`);
        values.push(age);
    }

    if(grade){
        fields.push(`grade=$${index++}`);
        values.push(grade);
    }

    values.push(id)

    if(fields.length == 0){
        return res.status(400).send("No fields available");
    }

    let query = `UPDATE students SET ${fields.join(", ")} WHERE id=$${index}`;

    try {
        let result = await con.query(query, values);
        
        if(result.rowCount == 0){
            return res.status(404).send("Student Not Found");
        }

        return res.send("Student Updated Successfully");

    } catch (err) {
        return res.status(500).send(err.message);
    }
})

‚≠êÔ∏è Mongo DB

# Install mongoDB package
npm install mongoose express

# Import Package
let mongoose = require("mongoose");

# Connection 

mongoose
    .connect("mongodb+srv://amanjrekar_db_user:EgYJM2D8K7XezMag@cluster0.jgbyezp.mongodb.net/crud")
    .then(()=>{ console.log("MongoDB connected"); })
    .catch((err)=>{ console.log(err.message) })

# POST REQUEST

Student.create({
    name,
    age,
    grade
});

// Another Way :
let emp1 = new Student({
    name,
    age,
    grade
})
emp1.save();

# GET ALL REQUEST

app.get("/api/students", async (req, res)=>{
    let students = await Student.find();
    console.log(students);
    res.json(students);
});

# GET BY ID REQUEST

app.get("/api/students/:id", async (req, res)=>{
    let id = req.params.id;
    let students = await Student.findById(id);
    res.json(students);
});

# PUT REQUEST 

app.put("/api/students/:id", async (req, res) => {
  try {
    const updated = await Student.findByIdAndUpdate(req.params.id, req.body);

    if (!updated) {
        return res.status(404).json({ message: 'Student not found' })
    };

    res.json(updated);
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
});

# PATCH REQUEST 

app.patch("/api/students/:id", async (req, res) => {
    let id = req.params.id;
    let body = req.body;

    if (Object.keys(body).length == 0) {
        return res.status(400).send("Please enter required fields")
    }

    try {
        // updated_student contains udpatedDocument or null(if id is wrong)
        let updated_student = await Student.findByIdAndUpdate(id, body); // It returns promise

        console.log(updated_student);

        if (!updated_student) {
            return res.status(404).json("Student Not Found");
        }

        res.json("Student updated successfully");
    } catch (err) {
        console.log(err.message);
        res.status(404).send(err.message)
    }
})

# DELETE REQUEST

app.delete("/api/students/:id", async (req, res)=>{

    let id = req.params.id;

    try {
        // deletedStudent contains deleted document or null(if no document with that ID exists)
        let deletedStudent = await Student.findByIdAndDelete(id);     // Student.findByIdAndDelete() returns a promise

        console.log(deletedStudent)

        if(!deletedStudent){
            return res.status(404).json("Student Not Found");
        }

        return res.send("Student Deleted Successfully");
    } catch (err) {
        
        return res.status(500).send(err.message);
    }
})

‚≠êÔ∏è Authentication

# Types :
1. Statefull : The server keeps track of user sessions.
2. Stateless(JWT) : The server does not store any session information.

# Stateful :

-> Client logs in 
-> if successful (server creates sessionID , Stores locally and send it to client using cookie)
-> when client send req, cookie is also added with the request.
-> Server get the cookie, verify it by locally saved data
-> If successful, server allows the client.

# Stateless :
-> Client logs in 
-> Token is generated with payload and signature(which have secret key).
-> sends back to client using cookie
-> when client send request, the JWT is also passed with it
-> Server verifies the JWT using the signature(which has secret key).
-> If successful, client request is accepted.

# JWT :

// Install Package :
npm install jsonwebtoken

// Import Package :
let jwt = require("jsonwebtoken");

// Create JWT token :
let secret_key = "APLO$123" // It is manual
return jwt.sign(payload, secret_key)    // Returns JWT // payload = object containing user info

// To verify Token
jwt.verify(token, secret_key) // Returns user info if valid else throws error

# Authorization :
const authorizeClient = (roles = []) => {
  return (req, res, next) => {
    if (!req.client || !roles.includes(req.client.role)) {
      return res.status(403).json({ msg: 'Forbidden: You are not authorized' });
    }
    next();
  };
};

‚ÄºÔ∏è Note : While sending JWT from server there are 2 standard ways :

1. Using Cookie(HttpOnly)
Use Case : Web app with session-style login

2. res.json() + Bearer token
Use Case : REST API or mobile app

‚≠êÔ∏è Cookies

// Install cookie Parser :
npm install cookie-parser

// Import cookie parser :
let cookieParser = require('cookie-parser');

// Add middleware to parse cookie from request header :
app.use(cookieParser());

// In Request Header (POSTMAN)
Key : Cookie
Value : sessionId=abc123; username=JohnDoe

// Te get cookie from req :
app.get("/", (req, res)=>{
    console.log("Cookies : ", req.cookies);        // Returns Object
    res.end("Hello World");
})

// To set cookie in response : 
app.get("/", (req, res)=>{

    res.cookie("uid", "abcd54321", {
        httpOnly : true,            // Not accessable by JS
        // domain: ".google.com"     // accessable to this domain only
        // maxAge: 24 * 60 * 60 * 1000, // 1 day
        // secure: true,  // Enable if using HTTPS
        // sameSite: 'strict' // Add for CSRF protection
    })
    res.end("Cookies has been set");
})
















